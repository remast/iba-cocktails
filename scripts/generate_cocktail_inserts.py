import json
import re
import unicodedata
from pathlib import Path

# -----------------------------------------------------------------------------
# generate_cocktail_inserts.py – Build seed SQL for cocktails & ingredients
# -----------------------------------------------------------------------------
# Reads recipes.json and emits a SQL script (sql/data_insert_cocktails.sql) that
# bulk-inserts all cocktails and their (matched) ingredients using the schema
# defined in:
#   • sql/ddl_create_cocktails.sql          (tables + slugify())
#   • sql/ddl_create_base_ingredients.sql   (seed base ingredients)
#
# Usage:
#   python scripts/generate_cocktail_inserts.py
#
# The generated SQL can be executed via psql:
#   psql -f sql/data_insert_cocktails.sql
# -----------------------------------------------------------------------------

# Paths
ROOT = Path(__file__).resolve().parent.parent
RECIPES_JSON = ROOT / "recipes.json"
BASE_ING_SQL = ROOT / "sql" / "ddl_create_base_ingredients.sql"
OUTPUT_SQL = ROOT / "sql" / "data_insert_cocktails.sql"


# --- helpers -----------------------------------------------------------------

def slugify(text: str) -> str:
    """Mirror the SQL slugify() helper (lowercase, ascii, dash-separated)."""
    # 1) strip accents + lowercase
    txt = unicodedata.normalize("NFKD", text).encode("ascii", "ignore").decode()
    txt = txt.lower()
    # 2) collapse whitespace to single dash
    txt = re.sub(r"\s+", "-", txt)
    # 3) remove non url-safe chars
    txt = re.sub(r"[^a-z0-9\-]", "", txt)
    return txt


def escape_sql(text: str | None) -> str:
    """Return SQL-safe single-quoted literal or NULL."""
    if text is None:
        return "NULL"
    return "'" + text.replace("'", "''") + "'"


# --- Parse base ingredients ---------------------------------------------------

def extract_base_slugs() -> set[str]:
    pattern = re.compile(r"slugify\('([^']+)'\)")
    names: set[str] = set()
    with BASE_ING_SQL.open("r", encoding="utf-8") as f:
        for line in f:
            m = pattern.search(line)
            if m:
                names.add(m.group(1))
    # Convert to slugs
    return {slugify(n) for n in names}


# --- Build SQL ----------------------------------------------------------------

def main():
    # Load data
    recipes = json.loads(RECIPES_JSON.read_text("utf-8"))
    valid_base_slugs = extract_base_slugs()

    out_lines: list[str] = [
        "-- -------------------------------------------------------------",
        "-- data_insert_cocktails.sql – Seed data for cocktails & ingredients",
        "-- ⚠️  Auto-generated by scripts/generate_cocktail_inserts.py",
        "--      DO NOT EDIT MANUALLY",
        "-- -------------------------------------------------------------\n",
    ]

    for recipe in recipes:
        name = recipe["name"]
        c_slug = slugify(name)
        glass = recipe.get("glass")
        category = recipe.get("category")
        garnish = recipe.get("garnish")
        prep = recipe.get("preparation")
        image_url = recipe.get("image_url")

        # Comment header
        out_lines.append(f"-- Cocktail: {name}")

        # 1) insert cocktail + capture id
        fields = [
            escape_sql(c_slug),
            escape_sql(name),
            escape_sql(glass),
            escape_sql(category),
            escape_sql(garnish),
            escape_sql(prep),
            escape_sql(image_url),
        ]
        out_lines.append(
            "WITH new_cocktail AS (\n    "
            "INSERT INTO cocktails (slug, name, glass, category, garnish, preparation, image_url)\n    "
            f"VALUES ({', '.join(fields)})\n    RETURNING id\n)"
        )

        # 2) insert ingredients
        ing_values: list[str] = []
        for pos, ing in enumerate(recipe.get("ingredients", []), start=1):
            # Only keep entries that map to a base ingredient
            ing_name = ing.get("ingredient")
            if not ing_name:
                continue  # skip 'special' only rows
            ing_slug = slugify(ing_name)
            if ing_slug not in valid_base_slugs:
                continue  # unknown base ingredient

            amount = ing.get("amount")
            unit = ing.get("unit")
            label = ing.get("label")
            special = ing.get("special")  # rarely present together with ingredient

            ing_values.append(
                "((SELECT id FROM new_cocktail), {pos}, (SELECT id FROM base_ingredients WHERE slug=slugify('{orig}')), {amt}, {unit}, {label}, {spec})".format(
                    pos=pos,
                    orig=ing_name.replace("'", "''"),
                    amt=(str(amount) if amount is not None else "NULL"),
                    unit=escape_sql(unit),
                    label=escape_sql(label),
                    spec=escape_sql(special),
                )
            )
        if ing_values:
            out_lines.append("INSERT INTO ingredients (cocktail_id, position, base_ingredient_id, amount, unit, label, special)\nVALUES")
            out_lines.append(
                "    " + ",\n    ".join(ing_values) + ";\n"
            )
        else:
            # Remove the WITH clause terminator when no ingredients
            out_lines[-1] += ";\n"  # simply terminate the INSERT
            out_lines.append("\n-- (No mapped ingredients)\n")

    # Write
    OUTPUT_SQL.write_text("\n".join(out_lines), encoding="utf-8")
    print(f"Wrote {OUTPUT_SQL.relative_to(ROOT)} with {len(recipes)} cocktails.")


if __name__ == "__main__":
    main() 